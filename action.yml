name: 'GitOps'
description: 'This GitHub Action can be used for our GitOps workflow. The GitHub Action will build and push the Docker image for your service and deploys the new version at our Kubernetes clusters.'
inputs:
  dockerenabled:
    description: 'Build and push the Docker Image'
    required: true
    default: 'true'
  dockerregistry:
    description: 'Docker Registry'
    required: true
    default: 'registry.staffbase.com'
  dockerimage:
    description: 'Docker Image'
    required: true
  dockerusername:
    description: 'Username for the Docker Registry'
    required: true
  dockerpassword:
    description: 'Password for the Docker Registry'
    required: true
  dockerfile:
    description: 'Dockerfile'
    required: true
    default: './Dockerfile'
  dockeradditionalbuildparams:
    description: 'List of Docker Build Parameters like: "--target runtime --build-arg ARG1=one --build-arg ARG2=two"'
    required: false
  gitopsenabled:
    description: 'Update manifest files in the GitOps repository'
    required: true
    default: 'true'
  gitopsorganization:
    description: 'GitHub Organization for GitOps'
    required: true
    default: 'Staffbase'
  gitopsrepository:
    description: 'GitHub Repository for GitOps'
    required: true
    default: 'mops'
  gitopsuser:
    description: 'GitHub User for GitOps'
    required: true
    default: 'Staffbot'
  gitopsemail:
    description: 'GitHub User for GitOps'
    required: true
    default: 'staffbot@staffbase.com'
  gitopstoken:
    description: 'GitHub Token for GitOps'
    required: true
  gitopsdev:
    description: 'Files which should be updated by the GitHub Action for DEV'
    required: false
  gitopsstage:
    description: 'Files which should be updated by the GitHub Action for STAGE'
    required: false
  gitopsprod:
    description: 'Files which should be updated by the GitHub Action for PROD'
    required: false
  workingdirectory:
    description: 'The directory (as a path relative to the repo root dir) in which the GitOps action should be executed. The dockerfile variable should be relative to workingdirectory.'
    required: false
    default: '.'

outputs:
  dockertag:
    description: 'Docker tag'
    value: ${{ steps.preparation.outputs.tag }}

runs:
  using: "composite"
  steps:
    - name: Generate Tags
      id: preparation
      shell: bash
      run: |
        if [[ $GITHUB_REF == refs/heads/master ]]; then
          TAG="master-${GITHUB_SHA::8}"
          LATEST="master"
          PUSH="true"
        elif [[ $GITHUB_REF == refs/heads/main ]]; then
          TAG="main-${GITHUB_SHA::8}"
          LATEST="main"
          PUSH="true"
        elif [[ $GITHUB_REF == refs/heads/dev ]]; then
          TAG="dev-${GITHUB_SHA::8}"
          LATEST="dev"
          PUSH="true"
        elif [[ $GITHUB_REF == refs/tags/v* ]]; then
          TAG="${GITHUB_REF:11}"
          LATEST="latest"
          PUSH="true"
        elif [[ $GITHUB_REF == refs/tags/* ]]; then
          TAG="${GITHUB_REF:10}"
          LATEST="latest"
          PUSH="true"
        else
          TAG="${GITHUB_SHA::8}"
          PUSH="false"
        fi

        echo ::set-output name=tag::${TAG}
        echo ::set-output name=latest::${LATEST}
        echo ::set-output name=push::${PUSH}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v1

    - name: Build
      id: docker_build
      uses: docker/build-push-action@v2
      with:
        context: .
        push: false
        file: ${{ inputs.dockerfile }}
        target: ${{ inputs.dockeradditionalbuildparams }}
        tags: ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}:${{ steps.preparation.outputs.tag }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Push the Docker Image
      shell: bash
      working-directory: ${{ inputs.workingdirectory }}
      run: |
        if [[ ${{ inputs.dockerenabled }} == "true" ]]; then
          echo The working directory is $(pwd)
          echo '${{ inputs.dockerpassword }}' | docker login ${{ inputs.dockerregistry }} -u '${{ inputs.dockerusername }}' --password-stdin

          if [[ ! -z "${{ steps.preparation.outputs.latest }}" ]]; then
            docker tag ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}:${{ steps.preparation.outputs.tag }} ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}:${{ steps.preparation.outputs.latest }}
          fi

          if [[ ${{ steps.preparation.outputs.push }} == "true" ]]; then
            docker push --all-tags ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}
          fi
        fi

#    - name: Build and Push the Docker Image
#      shell: bash
#      working-directory: ${{ inputs.workingdirectory }}
#      run: |
#        if [[ ${{ inputs.dockerenabled }} == "true" ]]; then
#          echo The working directory is $(pwd)
#          echo '${{ inputs.dockerpassword }}' | docker login ${{ inputs.dockerregistry }} -u '${{ inputs.dockerusername }}' --password-stdin
#
#          docker build ${{ inputs.dockeradditionalbuildparams }} -f ${{ inputs.dockerfile }} -t ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}:${{ steps.preparation.outputs.tag }} .
#
#          if [[ ! -z "${{ steps.preparation.outputs.latest }}" ]]; then
#            docker tag ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}:${{ steps.preparation.outputs.tag }} ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}:${{ steps.preparation.outputs.latest }}
#          fi
#
#          if [[ ${{ steps.preparation.outputs.push }} == "true" ]]; then
#            docker push --all-tags ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}
#          fi
#        fi

    - name: Update Docker Image in Repository
      shell: bash
      run: |
        commit_changes () {
          if [[ ${{ steps.preparation.outputs.push }} == "true" ]]; then
            git add . && git commit -m "Release ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}:${{ steps.preparation.outputs.tag }}"
            # In case there was another push in the meantime, we pull it again
            git pull --rebase https://${{ inputs.gitopsuser }}:${{ inputs.gitopstoken }}@github.com/${{ inputs.gitopsorganization }}/${{ inputs.gitopsrepository }}.git
            git push https://${{ inputs.gitopsuser }}:${{ inputs.gitopstoken }}@github.com/${{ inputs.gitopsorganization }}/${{ inputs.gitopsrepository }}.git
          fi
        }

        if [[ ${{ inputs.gitopsenabled }} == "true" ]]; then
          git config --global user.email "${{ inputs.gitopsemail }}" && git config --global user.name "${{ inputs.gitopsuser }}"

          git clone https://${{ inputs.gitopsuser }}:${{ inputs.gitopstoken }}@github.com/${{ inputs.gitopsorganization }}/${{ inputs.gitopsrepository }}.git .github/${{ inputs.gitopsrepository }}
          cd .github/${{ inputs.gitopsrepository }}
          echo "Repository ${{ inputs.gitopsorganization }}/${{ inputs.gitopsrepository }} was cloned successfully "

          if [[ ( $GITHUB_REF == refs/heads/master || $GITHUB_REF == refs/heads/main ) && -n "${{ inputs.gitopsstage }}" ]]; then
            echo "Run update for STAGE"
            while IFS= read -r line; do
              echo "Check if path $line exists and get old current version"
              ../gitops/yq r -e $line
              echo "Run update $line ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}:${{ steps.preparation.outputs.tag }}"
              ../gitops/yq w -i $line ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}:${{ steps.preparation.outputs.tag }}
            done <<< "${{ inputs.gitopsstage }}"
            commit_changes

          elif [[ $GITHUB_REF == refs/heads/dev && -n "${{ inputs.gitopsdev }}" ]]; then
            echo "Run update for DEV"
            while IFS= read -r line; do
              echo "Check if path $line exists and get old current version"
              ../gitops/yq r -e $line
              echo "Run update $line ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}:${{ steps.preparation.outputs.tag }}"
              ../gitops/yq w -i $line ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}:${{ steps.preparation.outputs.tag }}
            done <<< "${{ inputs.gitopsdev }}"
            commit_changes

          elif [[ $GITHUB_REF == refs/tags/* && -n "${{ inputs.gitopsprod }}" ]]; then
            echo "Run update for PROD"
            while IFS= read -r line; do
              echo "Check if path $line exists and get old current version"
              ../gitops/yq r -e $line
              echo "Run update $line ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}:${{ steps.preparation.outputs.tag }}"
              ../gitops/yq w -i $line ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}:${{ steps.preparation.outputs.tag }}
            done <<< "${{ inputs.gitopsprod }}"
            commit_changes

          elif [[ -n "${{ inputs.gitopsdev }}" ]]; then
            echo "Simulate update for DEV"
            while IFS= read -r line; do
              echo "Check if path $line exists and get old current version"
              ../gitops/yq r -e $line
              echo "Run update $line ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}:${{ steps.preparation.outputs.tag }}"
              ../gitops/yq w -i $line ${{ inputs.dockerregistry }}/${{ inputs.dockerimage }}:${{ steps.preparation.outputs.tag }}
            done <<< "${{ inputs.gitopsdev }}"
            commit_changes
          fi
        fi
